using NUnit.Framework;
using NUnit.Framework.Legacy;
using StaticMock.Entities;

namespace StaticMock.Tests.Tests.Examples.RealWorldExamples;

[TestFixture]
public class EnterpriseScenarios
{
    [Test]
    public void Financial_Trading_System_Risk_Calculation()
    {
        using var marketDataMock = Mock.Setup(() => DateTime.Now)
            .Returns(new DateTime(2024, 1, 15, 9, 30, 0));

        using var timeMock = Mock.Setup(() => DateTime.UtcNow)
            .Returns(new DateTime(2024, 1, 15, 9, 30, 0, DateTimeKind.Utc));

        // Mock audit logging to verify risk calculations are logged
        var auditEntries = new List<string>();
        using var auditMock = Mock.Setup(context =>
                File.AppendAllText(context.It.IsAny<string>(), context.It.IsAny<string>()))
            .Callback<string, string>((_, content) => auditEntries.Add(content));

        // Act: Simulate risk calculation
        var portfolioId = "TEST_PORTFOLIO_001";
        var calculatedRisk = 0.12m; // 12% VaR
        var timestamp = DateTime.Now;

        File.AppendAllText("risk_audit.log",
            $"Portfolio: {portfolioId}, Risk: {calculatedRisk:P}, Time: {timestamp}");

        // Assert: Verify risk calculation and compliance
        ClassicAssert.AreEqual(new DateTime(2024, 1, 15, 9, 30, 0), timestamp);
        ClassicAssert.AreEqual(1, auditEntries.Count);
        ClassicAssert.IsTrue(auditEntries[0].Contains(portfolioId));
        ClassicAssert.IsTrue(auditEntries[0].Contains("12"));
    }

    [Test]
    public void Legacy_Code_Modernization_File_Processing()
    {
        // Arrange: Mock the complex legacy dependencies
        var testConfig = "connection_string=test_db;timeout=30";

        using var pathMock = Mock.Setup(() => Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData))
            .Returns(@"C:\TestConfig");

        using var fileMock = Mock.Setup(context =>
                File.ReadAllText(context.It.Is<string>(path => path.EndsWith("inventory.config"))))
            .Returns(testConfig);

        var mockWarehouseData = new[]
        {
            "WH001,ITEM001,150",
            "WH002,ITEM002,200",
            "WH003,ITEM003,75"
        };

        using var csvMock = Mock.Setup(context =>
                File.ReadAllLines(context.It.IsAny<string>()))
            .Returns(mockWarehouseData);

        using var userMock = Mock.Setup(() => Environment.UserName)
            .Returns("TestUser");

        var auditEntries = new List<string>();
        using var auditMock = Mock.Setup(context =>
                File.AppendAllText(context.It.IsAny<string>(), context.It.IsAny<string>()))
            .Callback<string, string>((_, content) => auditEntries.Add(content));

        // Act: Simulate legacy inventory processing
        var configPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "inventory.config");
        var config = File.ReadAllText(configPath);
        var warehouseData = File.ReadAllLines("warehouse_data.csv");
        var user = Environment.UserName;

        File.AppendAllText("audit.log", $"Report generated by {user} with {warehouseData.Length} items");

        // Assert: Verify the report and all interactions
        ClassicAssert.IsNotNull(config);
        ClassicAssert.IsTrue(config.Contains("test_db"));
        ClassicAssert.AreEqual(3, warehouseData.Length);
        ClassicAssert.AreEqual("TestUser", user);

        // Verify audit loggingadd
        ClassicAssert.AreEqual(1, auditEntries.Count);
        ClassicAssert.IsTrue(auditEntries[0].Contains("TestUser"));
        ClassicAssert.IsTrue(auditEntries[0].Contains("3 items"));
    }

    [Test]
#if NETFRAMEWORK
    [Ignore("Web API order processing flow test is not supported on .NET Framework. Environment.TickCount has NotSupported in StaticMock for .NET Framework (Body-less method).")]
#endif
    public void Web_API_Order_Processing_Flow()
    {
        // Arrange: Set up comprehensive mocking for order processing
        const string testOrderId = "ORDER_12345";
        const string customerId = "CUST_67890";

        // Mock inventory checks
        using var inventoryMock = Mock.Setup(context =>
                File.Exists(context.It.IsAny<string>()))
            .Returns(true);

        // Mock pricing calculation
        using var pricingMock = Mock.Setup(context =>
                Math.Round(context.It.IsAny<decimal>(), 2))
            .Returns(118.77m);

        // Mock environment for payment processing simulation
        using var paymentMock = Mock.Setup(() => Environment.TickCount)
            .Returns(123); // Mock successful payment (odd number indicates success)

        // Mock order persistence
        var savedOrders = new List<string>();
        using var orderSaveMock = Mock.Setup(context =>
                File.WriteAllText(context.It.IsAny<string>(), context.It.IsAny<string>()))
            .Callback<string, string>((_, content) => savedOrders.Add(content));

        // Mock notification service
        var sentNotifications = new List<string>();
        using var notificationMock = Mock.Setup(context =>
                File.AppendAllText(context.It.IsAny<string>(), context.It.IsAny<string>()))
            .Callback<string, string>((_, content) => sentNotifications.Add(content));

        // Act: Process the order
        var inventoryAvailable = File.Exists($"inventory_{testOrderId}.json");
        var totalPrice = Math.Round(109.97m + 8.80m, 2);
        var paymentResult = Environment.TickCount;
        var paymentSuccessful = paymentResult % 2 == 1;

        if (inventoryAvailable && paymentSuccessful)
        {
            File.WriteAllText($"orders/{testOrderId}.json", $"{{\"orderId\":\"{testOrderId}\",\"customerId\":\"{customerId}\",\"total\":{totalPrice}}}");
            File.AppendAllText("notifications.log", $"Order confirmation sent to {customerId} for {testOrderId}");
        }

        // Assert: Verify complete order processing
        ClassicAssert.IsTrue(inventoryAvailable);
        ClassicAssert.AreEqual(118.77m, totalPrice);
        ClassicAssert.IsTrue(paymentSuccessful);

        // Verify order was saved correctly
        ClassicAssert.AreEqual(1, savedOrders.Count);
        ClassicAssert.IsTrue(savedOrders[0].Contains(testOrderId));
        ClassicAssert.IsTrue(savedOrders[0].Contains(customerId));

        // Verify notification was sent
        ClassicAssert.AreEqual(1, sentNotifications.Count);
        ClassicAssert.IsTrue(sentNotifications[0].Contains(customerId));
    }

    [Test]
    public void Document_Management_With_Virus_Scanning()
    {
        // Arrange: Complex document processing pipeline
        var testDocument = new
        {
            FileName = "important_contract.pdf",
            UserId = "USER_12345",
            Category = "Contracts",
            Size = 1024 * 50 // 50KB
        };

        var expectedPath = Path.Combine(@"C:\Documents\Contracts\2024\01", testDocument.FileName);

        // Mock file system operations
        using var directoryExistsMock = Mock.Setup(context =>
                Directory.Exists(context.It.IsAny<string>()))
            .Returns(false);

        using var directoryCreateMock = Mock.Setup(context =>
                Directory.CreateDirectory(context.It.IsAny<string>()))
            .Returns(new DirectoryInfo(@"C:\Documents\Contracts\2024\01"));

        using var fileWriteMock = Mock.SetupAction(typeof(File), nameof(File.WriteAllBytes), new SetupProperties { MethodParametersTypes = [typeof(string), typeof(byte[])] })
            .Callback<string, byte[]>((_, _) => { /* File write simulated */ });

        // Mock virus scanning (simulate with file size check)
        using var virusScanMock = Mock.Setup(context =>
                Math.Max(0, context.It.IsAny<int>()))
            .Returns(testDocument.Size); // Clean files return their size

        // Mock audit logging
        var auditEntries = new List<string>();
        using var auditMock = Mock.Setup(context =>
                File.AppendAllText(context.It.IsAny<string>(), context.It.IsAny<string>()))
            .Callback<string, string>((_, content) => auditEntries.Add(content));

        // Act: Upload the document
        var directoryPath = Path.GetDirectoryName(expectedPath);
        var directoryExists = Directory.Exists(directoryPath);

        if (!directoryExists)
        {
            if (directoryPath != null) Directory.CreateDirectory(directoryPath);
        }

        var documentBytes = new byte[testDocument.Size];
        File.WriteAllBytes(expectedPath, documentBytes);

        // Simulate virus scan
        var scanResult = Math.Max(0, testDocument.Size);
        var isClean = scanResult == testDocument.Size;

        if (isClean)
        {
            File.AppendAllText("document_audit.log",
                $"Document uploaded: {testDocument.FileName} by {testDocument.UserId}, Size: {testDocument.Size}");
        }

        // Assert: Verify complete upload process
        ClassicAssert.IsFalse(directoryExists); // Directory didn't exist initially
        ClassicAssert.IsTrue(isClean); // File passed virus scan
        ClassicAssert.AreEqual(testDocument.Size, scanResult);

        // Verify audit trail
        ClassicAssert.AreEqual(1, auditEntries.Count);
        ClassicAssert.IsTrue(auditEntries[0].Contains(testDocument.UserId));
        ClassicAssert.IsTrue(auditEntries[0].Contains(testDocument.FileName));
    }
}